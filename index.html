<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>List&period; Any way you like&period;</title>
        <style>
</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="list-any-way-you-like">List. Any way you like.</h1>
<h2 id="jsdoc-documentation"><a href="/out/List.html">JSDoc Documentation</a></h2>
<h2 id="test-documentation"><a href="/out/test.report.html">Test Documentation</a></h2>
<p>Based on CodeWars 2kyu Kata: <a href="https://www.codewars.com/kata/59f7a040a5b820c684000046">Link to challenge</a></p>
<p>JavaScript Arrays can only represent lists of finite length. Your job is to implement the List class, which must be able to represent both finite and infinite lists. It must support the class and instance methods specified below. Methods must not have side effects ( mutating any argument would be a side effect ).</p>
<p>The internal representation of List is completely free. With great power, however, comes great responsibility: you need to supply adequate laziness to support infinite lists yourself. E.g. [ infinite elements ].map( function ) or [ infinite elements ].append( [ (in)finite elements ] ) should return a new [ infinite elements ].</p>
<h2 id="class-methods">Class methods</h2>
<p><code>List.empty</code>, <code>.iterate(fn,x)</code>, <code>.repeat(x)</code>, <code>.cycle(xs)</code>, <code>.replicate(n,x)</code>, <code>.fromList(xs)</code></p>
<p>where fn is a function, xs is a list, x is an element (a value) and n is a number.</p>
<hr>
<h2 id="instance-methods">Instance methods</h2>
<p><code>list.head()</code>, <code>.tail()</code>, <code>.init()</code>, <code>.last()</code>, <code>.length()</code>, <code>.toList()</code>, <code>.get(i)</code>, <code>.nil()</code>, <code>.take(n)</code>, <code>.drop(n)</code>, <code>.cons(x)</code>, <code>.append(xs)</code>, <code>.slice(i,j)</code>, <code>.map(fn)</code>, <code>.filter(fn)</code>, <code>.reverse()</code>, <code>.concat()</code>, <code>.concatMap(fn)</code>, <code>.zipWith(fn,xs)</code>, <code>.foldr(fn,x)</code>, <code>.foldl(fn,x)</code>, <code>.scanr(fn,x)</code>, <code>.scanl(fn,x)</code>, <code>.elem(x)</code>, <code>.elemIndex(x)</code>, <code>.find(fn)</code>, <code>.findIndex(fn)</code>, <code>.any(fn)</code>, <code>.all(fn)</code>, <code>.the()</code></p>
<p>where fn is a function, xs is a list, x is an element (a value), i,j are indices and n is a number (a sort of index).</p>
<hr>
<h2 id="more-class-methods">More class methods</h2>
<p>You will also need to implement some use cases of infinite lists.</p>
<blockquote>
<p>List.PRIME: an infinite list of all prime numbers ([ 2, 3, 5, 7, 11, 13, 17, 19, .. ] )
You might use primes = filterPrime [2..] where filterPrime (p:xs) = p : filterPrime [x | x &lt;- xs, x <code>mod</code> p /= 0] from <a href="http://haskell.org">haskell.org</a>. It can be written quite elegantly using List. (Don't worry too much about efficiency for this.)</p>
</blockquote>
<blockquote>
<p>List.FIB: an infinite list of Fibonacci (0,1) numbers ( [ 0, 1, 1, 2, 3, 5, 8, 13, .. ] )
You might use fib = 0 : 1 : zipWith (+) fib (tail fib). (Again, elegance over efficiency.)</p>
</blockquote>
<blockquote>
<p>arctan(x) can be written as an infinite sum 0 + x^1/1 - x^3/3 + x^5/5 - x^7/7 ..
Ï€ is equal to 4 * ( arctan(1/2) + arctan(1/3) )</p>
</blockquote>
<blockquote>
<p>List.PI: an infinite list of increasing numbers of terms (taken pairwise) of this infinite sum
( [ 0, 4*(1/2+1/3), 4*(1/2+1/3 - 1/8/3-1/27/3), 4*(1/2+1/3 - 1/8/3-1/27/3 + 1/32/5+1/243/5), .. ] )
This one is actually quite efficient ! even though it can converge faster still with other constants. But these look nice. :P
notes</p>
</blockquote>
<p>Unlike in Haskell, the head, tail, init and last of an empty list are defined. Also, the is defined for all lists ( and can be determined, except in case of an infinite list of all equal elements ).
Diverging results and list values at out-of-bounds indices are undefined ( not necessarily undefined ! ).
take and drop have defined results for out-of-bounds arguments, but slice does not.
Undefined results may result in any value or action.
All test inputs are valid and should result in a defined result.</p>
<hr>
<h2 id="class-methods-1">Class methods</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> List.empty =&gt; an (or the) empty list ( must not require () )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> List.iterate(fn,x) =&gt; an infinite list of successive applications of fn to x</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> List.repeat(x) =&gt; an infinite list, every element of which is x</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> List.cycle(xs) =&gt; an infinite list of repetitions of xs ( equals xs if xs is infinite )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> List.replicate(n,x) =&gt; a finite list of length n, every element of which is x</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> List.fromList(xs) =&gt; xs converted to a list ( an Array must be a valid xs )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> List.PRIME, List.FIB, List.PI =&gt; ( must not require () )</li>
</ul>
<hr>
<h2 id="instance-methods-1">Instance methods</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.head() =&gt; the first element of list, or undefined for empty list</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.tail() =&gt; list without its first element, or an empty list for empty list</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.init() =&gt; list without its last element, or an empty list for empty list ( equals list if list is infinite )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.last() =&gt; the last element of list, or undefined for empty list ( diverges for infinite list )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.length() =&gt; the length of list ( diverges for infinite list )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.toList() =&gt; list converted to an Array ( diverges for infinite list )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.get(i) =&gt; the element of list at index i</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.nil() =&gt; true for empty list, false otherwise ( null in Haskell )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.take(n) =&gt; the first (at most) n elements of list ( n may be negative or greater than list.length() )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.drop(n) =&gt; list without its first ( at most ) n elements ( n may be negative or greater than list.length() )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.cons(x) =&gt; x prepended to list</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.append(xs) =&gt; xs appended to list ( equals list if list is infinite )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.slice(i,j) =&gt; list from index i (inclusive) to index j (exclusive) ( both arguments are optional; result is undefined for arguments not in list )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.map(fn) =&gt; list transformed by fn</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.filter(fn) =&gt; only the elements of list for which fn holds</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.reverse() =&gt; list in reverse order ( diverges for infinite list )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.concat() =&gt; list flattened; list must be a list of lists ( behaves differently than .concat() in JavaScript ! )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.concatMap(fn) =&gt; list transformed by fn, then flattened</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.zipWith(fn,xs) =&gt; map, but with two lists ( fn will normally be a binary function )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.foldr(fn,x) =&gt; right-associative reduction of list to a single value ( [x1,x2,..,xn].foldr(fn,z) = fn( x1, fn( x2, .. fn( xn, z ) ) ) ) ( foldr should only recursively evaluate necessary fn arguments, as to return a valid value from a nullary or unary fn even if list is infinite ) ( not quite .reduceRight() in JavaScript )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.foldl(fn,x) =&gt; left-associative reduction of list to a single value ( [x1,x2,..,xn].foldl(fn,z) = fn( .. fn( fn( z, x1 ), x2 ) .., xn ) ) ( diverges for infinite list ) ( .reduce() in JavaScript )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.scanr(fn,x) =&gt; right-associative incremental reduction of list to a list ( [x1,x2,..,xn].scanr(fn,z) = [ fn( x1, .. ), .., fn( x(n-1), fn( xn, z ) ), fn( xn, z ), z ] ) ( scanr should only recursively evaluate necessary fn arguments, as to return a valid value from a nullary or unary fn even if list is infinite. earlier versions of the kata did not have this requirement, so this is tested for Bonus Points only )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.scanl(fn,x) =&gt; left-associative incremental reduction of list to a list ( [x1,x2,..,xn].scanl(fn,z) = [ z, fn( z, x1 ), fn( fn( z, x1 ), x2 ), .., fn( .., xn ) ] )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.elem(x) =&gt; true if list contains x, false otherwise ( possibly diverges for infinite list ) ( .includes() in JavaScript )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.elemIndex(x) =&gt; index of x in list, or -1 if list does not contain x ( possibly diverges for infinite list ) ( .indexOf() in JavaScript )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.find(fn) =&gt; the first element of list for which fn holds ( possibly diverges for infinite list )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.findIndex(fn) =&gt; the first index in list for which fn holds ( possibly diverges for infinite list )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.any(fn) =&gt; true if fn holds for any element of list, false otherwise ( possibly diverges for infinite list ) ( .some() in JavaScript )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.all(fn) =&gt; true if fn holds for all elements of list, false otherwise ( possibly diverges for infinite list ) ( .every() in JavaScript )</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> list.the() =&gt; any element of list if all elements of list are equal, undefined otherwise ( possibly diverges for infinite list )</li>
</ul>
<hr>
<h2 id="hints">Hints</h2>
<ul>
<li>options for underlying datatype</li>
<li>achieving laziness</li>
<li>determining function arity</li>
<li>reference guides</li>
</ul>

    </body>
    </html>